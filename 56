#pragma warning(disable:4996)
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <locale.h>
#include <math.h>
double const RAND_MAX_F = RAND_MAX;

//////////////////////////////////////////////////////////////////////////////
/**
* Возвращает вещественное случайное число, равномерно распределённое
* на полуоткрытом интервале [a, b).
*
* @param a нижняя граница
* @param b верхняя граница
*
* @return Случайное число от a до b (не включая верхнюю границу).
*/
double Random(double a, double b) {

    double r;
    r = rand() / RAND_MAX_F * (b - a) + a;
    return r;
}
/**
* Заполняет массив равномерно распределёнными случайными числами.
*
* @param arr массив
* @param size количество элементов в массиве
* @param a нижняя граница
* @param b верхняя граница (не включается в интервал)
*
* @see Random()
*/
void FillRandom(double arr[], int size, double a, double b) {

    for(int i = 0; i < size; i++)
    {
        arr[i] = Random(a,b);
    }
}
/**
* Печатает элементы массива через запятую в фигурных скобках.
*
* @param arr массив
* @param size количество элементов в массиве
*/
void Print(double const arr[], int size) {
    for (int i = 0; i < size; i ++)
    {
        printf("%f\n", arr[i]);
    }
}
//////////////////////////////////////////////////////////////////////////////
/**
* Строит гистограмму значений элементов массива.
*
* Заполняет массив counters[] на основании значений элементов массива arr[],
* подсчитывая, сколько их попало в соответствующий подынтервал
* полного интервала [a, b). Элементы массива, не попадающие в указанный
* интервал от a до b игнорируются.
*
* @param arr массив
* @param size количество элементов в массиве
* @param a нижняя граница
* @param b верхняя граница (не включается в интервал)
* @param counters заполняемый массив
* @param numCounters количество подынтервалов подсчёта
*/
void BuildHistogram(double const arr[], int size,
                    double left, double right, int counters[], int numCounters) {
    for (int i = 0; i < numCounters; ++i) {
        counters[i] = 0;
    }
    for (int i = 0; i < size; ++i) {
        ++counters[(int)((arr[i] - left) / (right - left) * numCounters)];
    }
    // TODO: 2. Вычислите данные для гистограммы.
}
/**
* Печатает элементы массива через запятую в фигурных скобках.
*
* @param counters массив
* @param numCounters количество элементов в массиве
*/
void PrintHistogram(int counters[], int numCounters) {
    for (int i = 0; i < numCounters; ++i) {
        printf("%d\n", counters[i]);
    }
}

double m(const int* arr, int size) {
    double m = arr[0];
    for (int i = 1; i < size; ++i) {
        if (arr[i] > m) {
            m = arr[i];
        }
    }
    return m;

    // TODO: 2. Вычислите данные для гистограммы.
}
#define HIST_CHAR_BAR 'o'
#define HIST_CHAR_SPACE 183
/**
* Печатает горизонтальную гистограмму значений элементов массива.
*
* @param counters массив интервалов, содержащий количество элементов,
* попавших в соответствующий подынтервал
* @param numCounters количество подынтервалов подсчёта
* @param width полная ширина поля вывода гистограммы, в знакоместах
*/
void DrawHistogram(int counters[], int numCounters, int width) {
    double p = m(counters, numCounters) / (double)width;
    for (int i = 0; i < numCounters; ++i) {
        printf("%d ", i);
        for (int j = 0; j < counters[i] / p; ++j) {
            printf("%c", HIST_CHAR_BAR);
        }
        int t = 0;
        if (counters[i] > 0){
            t = 1;
        }
        for (int j = 0; j < width - counters[i] / p - t; ++j) {
            printf("%c", HIST_CHAR_SPACE);
        }
        printf("\n");
    }

    // TODO: 3. Нарисуйте диаграмму.
}

//////////////////////////////////////////////////////////////////////////////
int main(void) {
    const int PRINT_MAX = 20;
    const double RANDOM_MIN = 0.2;
    const double RANDOM_MAX = 0.6;
    const double HIST_MIN = 0.0;
    const double HIST_MAX = 1.0;
    const int HIST_LINES = 5;
    const int HIST_LENGTH = 16;
    int size = 10;
    double *numbers = NULL;
    int *hist = NULL;
    setlocale(LC_CTYPE, "Russian");
    srand(time(NULL));
    // TODO: 0. Взляните на случайные числа. Напечатайте несколько в цикле.
    // При желании можно рандомизировать ГПСЧ текущим числом секунд
    // srand((unsigned)time(0));
    // ...
    // Подготовьтесь к эксперименту
    printf("\nPut in number of digits: ");
    scanf("%i", &size);
    // Выделите память
    numbers = malloc(size * sizeof(double));
    hist = malloc(HIST_LINES * sizeof(int));
    // Заполните массивы
    printf("\nUniform SV (first% i numbers):\n", PRINT_MAX);
    FillRandom(numbers, size, RANDOM_MIN, RANDOM_MAX);
    Print(numbers, size < PRINT_MAX ? size : PRINT_MAX);
    // Постройте гистограмму равномерной случайной величины
    BuildHistogram(numbers, size, HIST_MIN, HIST_MAX, hist, HIST_LINES);
    PrintHistogram(hist, HIST_LINES);
    DrawHistogram(hist, HIST_LINES, HIST_LENGTH);
    // Освободите память
    free(hist);
    free(numbers);
    return 0;
}
